common/cache/facts_cache.py:284: in wrapper
    facts = target(*args, **kargs)
            ^^^^^^^^^^^^^^^^^^^^^^
        _zone_getter = <function _get_default_zone at 0x7f2f4b86a5c0>
        after_read = None
        args       = (<SonicHost bjw3-can-7060-7>,)
        before_write = None
        cache      = <tests.common.cache.facts_cache.FactsCache object at 0x7f2f4b9fd970>
        cached_facts = <object object at 0x7f2f4c12fd90>
        disable_cache = False
        kargs      = {}
        name       = 'basic_facts'
        target     = <function SonicHost._gather_facts at 0x7f2f4ae951c0>
        zone       = 'bjw3-can-7060-7'
        zone_getter = None
common/devices/sonic.py:221: in _gather_facts
    facts = self._get_platform_info()
            ^^^^^^^^^^^^^^^^^^^^^^^^^
        self       = <SonicHost bjw3-can-7060-7>
common/devices/sonic.py:350: in _get_platform_info
    platform_info = self.command("show platform summary")["stdout_lines"]
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        self       = <SonicHost bjw3-can-7060-7>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <SonicHost bjw3-can-7060-7>, module_args = ['show platform summary'], complex_args = {}
previous_frame = <frame at 0x7f2f4919b880, file '/var/src/sonic-mgmt-int/tests/common/devices/sonic.py', line 350, code _get_platform_info>
filename = '/var/src/sonic-mgmt-int/tests/common/devices/sonic.py', line_number = 350, function_name = '_get_platform_info'
lines = ['        platform_info = self.command("show platform summary")["stdout_lines"]\n'], index = 0, verbose = True, module_ignore_errors = False
module_async = False

    def _run(self, *module_args, **complex_args):
    
        previous_frame = inspect.currentframe().f_back
        filename, line_number, function_name, lines, index = inspect.getframeinfo(previous_frame)
    
        verbose = complex_args.pop('verbose', True)
    
        if verbose:
            logger.debug(
                "{}::{}#{}: [{}] AnsibleModule::{}, args={}, kwargs={}".format(
                    filename,
                    function_name,
                    line_number,
                    self.hostname,
                    self.module_name,
                    json.dumps(module_args, cls=AnsibleHostBase.CustomEncoder),
                    json.dumps(complex_args, cls=AnsibleHostBase.CustomEncoder)
                )
            )
        else:
            logger.debug(
                "{}::{}#{}: [{}] AnsibleModule::{} executing...".format(
                    filename,
                    function_name,
                    line_number,
                    self.hostname,
                    self.module_name
                )
            )
    
        module_ignore_errors = complex_args.pop('module_ignore_errors', False)
        module_async = complex_args.pop('module_async', False)
    
        if module_async:
            def run_module(module_args, complex_args):
                return self.module(*module_args, **complex_args)[self.hostname]
            pool = ThreadPool()
            result = pool.apply_async(run_module, (module_args, complex_args))
            return pool, result
    
        module_args = json.loads(json.dumps(module_args, cls=AnsibleHostBase.CustomEncoder))
        complex_args = json.loads(json.dumps(complex_args, cls=AnsibleHostBase.CustomEncoder))
    
        adhoc_res: AdHocResult = self.module(*module_args, **complex_args)
    
        if self.module_name == "meta":
            # The meta module is special in Ansible - it doesn't execute on remote hosts, it controls Ansible's behavior
            # There are no per-host ModuleResults contained within it
            return
    
        hostname_res: ModuleResult = adhoc_res[self.hostname]
        hostname_res.encoder = AnsibleHostBase.CustomEncoder
    
        if verbose:
            logger.debug(
                "{}::{}#{}: [{}] AnsibleModule::{} Result => {}".format(
                    filename,
                    function_name,
                    line_number,
                    self.hostname,
                    self.module_name, json.dumps(hostname_res, cls=AnsibleHostBase.CustomEncoder)
                )
            )
        else:
            logger.debug(
                "{}::{}#{}: [{}] AnsibleModule::{} done, is_failed={}, rc={}".format(
                    filename,
                    function_name,
                    line_number,
                    self.hostname,
                    self.module_name,
                    hostname_res.is_failed,
                    hostname_res.get('rc', None)
                )
            )
    
        if (hostname_res.is_failed or 'exception' in hostname_res) and not module_ignore_errors:
>           raise RunAnsibleModuleFail("run module {} failed".format(self.module_name), hostname_res)
E           tests.common.errors.RunAnsibleModuleFail: run module command failed, Ansible Results =>
E           failed = True
E           msg = 'dict object' has no attribute 'altpasswords'
E           _ansible_no_log = False
E           stdout =
E           stderr =
